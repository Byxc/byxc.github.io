{"meta":{"title":"白云心城的博客","subtitle":null,"description":null,"author":"白云心城","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Class的本质","slug":"Class的本质","date":"2019-11-25T07:14:55.000Z","updated":"2019-11-25T10:17:14.097Z","comments":true,"path":"2019/11/25/Class的本质/","link":"","permalink":"http://yoursite.com/2019/11/25/Class的本质/","excerpt":"根据之前我们对 OC 对象本质的探讨中我们知道，Class 对象其实是一个指向 objc_class 结构体的指针。不管事类对象还是元类对象，其类型都是 Class，也就是说其底层其实都是 objc_class 结构体指针。","text":"根据之前我们对 OC 对象本质的探讨中我们知道，Class 对象其实是一个指向 objc_class 结构体的指针。不管事类对象还是元类对象，其类型都是 Class，也就是说其底层其实都是 objc_class 结构体指针。 我们可以点击 Class 查看其内部代码： 123456789101112131415161718192021#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 其中有很多 OBJC2_UNAVAILABLE 标记，表示目前这些代码已经被弃用了，我们可以通过 objc 源码查找目前 objc_class 结构体的内容，如下： 123456789101112131415161718192021222324252627struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable(方法缓存) class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags(类的具体信息) class_rw_t *data() &#123; return bits.data(); &#125; void setData(class_rw_t *newData) &#123; bits.setData(newData); &#125; // 中间省略部分代码 ... void chooseClassArrayIndex(); void setClassArrayIndex(unsigned Idx) &#123; bits.setClassArrayIndex(Idx); &#125; unsigned classArrayIndex() &#123; return bits.classArrayIndex(); &#125;&#125;; 我们发现 objc_class 这个结构体继承 objc_object，我们再找到 objc_object 的代码： 12345678910111213141516171819202122struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); // 中间省略部分代码 ... bool sidetable_tryRetain(); uintptr_t sidetable_retainCount();#if DEBUG bool sidetable_present();#endif&#125;; 我们发现 objc_object 中存在一个 isa 指针，由于继承关系，也就是说 objc_class 同样拥有 isa 指针。 那么我们之前了解到的，类中存储类的成员变量信息、实例方法这些信息存在哪里呢？我们可以在 class_rw_t 结构体中找到一些信息： 12345678910111213141516171819202122232425262728293031323334struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; // 方法列表 method_array_t methods; // 属性列表 property_array_t properties; // 协议列表 protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; // 中间省略部分代码 ... // set and clear must not overlap void changeFlags(uint32_t set, uint32_t clear) &#123; assert((set &amp; clear) == 0); uint32_t oldf, newf; do &#123; oldf = flags; newf = (oldf | set) &amp; ~clear; &#125; while (!OSAtomicCompareAndSwap32Barrier(oldf, newf, (volatile int32_t *)&amp;flags)); &#125;&#125;; 可以发现其中包含方法列表、属性列表、协议列表等信息。而 class_rw_t 是通过 bits 调用 data 方法获得的，通过查看方法内部实现我们可以知道 data 函数内部仅仅是对 bits 进行 &amp; FAST_DATA_MASK 操作，其值为 0x00007ffffffffff8UL。 123456// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8ULclass_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 而成员变量信息则是存在 class_ro_t 中的，其内部代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; uint32_t flags; uint32_t instanceStart; // 实例对象大小 uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; // 类名 const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; // 成员变量列表 const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0]; _objc_swiftMetadataInitializer swiftMetadataInitializer() const &#123; if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123; return _swiftMetadataInitializer_NEVER_USE[0]; &#125; else &#123; return nil; &#125; &#125; method_list_t *baseMethods() const &#123; return baseMethodList; &#125; class_ro_t *duplicate() const &#123; if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123; size_t size = sizeof(*this) + sizeof(_swiftMetadataInitializer_NEVER_USE[0]); class_ro_t *ro = (class_ro_t *)memdup(this, size); ro-&gt;_swiftMetadataInitializer_NEVER_USE[0] = this-&gt;_swiftMetadataInitializer_NEVER_USE[0]; return ro; &#125; else &#123; size_t size = sizeof(*this); class_ro_t *ro = (class_ro_t *)memdup(this, size); return ro; &#125; &#125;&#125; 可使用下图描述之间的关系","categories":[],"tags":[]},{"title":"OC对象的本质","slug":"OC对象的本质","date":"2019-11-18T05:37:01.000Z","updated":"2019-11-18T12:11:11.630Z","comments":true,"path":"2019/11/18/OC对象的本质/","link":"","permalink":"http://yoursite.com/2019/11/18/OC对象的本质/","excerpt":"什么是OC语言，OC对象、类的本质是什么，OC对象的内存布局是什么样子的，一个NSObject对象占用多少内存，一个自定义类的对象的本质及占用多少内存？","text":"什么是OC语言，OC对象、类的本质是什么，OC对象的内存布局是什么样子的，一个NSObject对象占用多少内存，一个自定义类的对象的本质及占用多少内存？ 1. 什么是OC语言？首先我们谈谈什么是做编程语言，编程语言是一种让人们能读懂并且能够展现程序的执行行为的语言，包括语法（正确的表达式以及状态机的使用规则）以及语义（如何去组织这些表达式以及状态机以一种有意义的方式去完成我们的目标）。Objective-C 底层其实是 C\\C++ 代码，OC 的对象结构都是通过C\\C++ 结构体实现的。 我们可以通过命令行将 OC 的 .m 文件转换为对应的 c++ 文件： 12345// 这种方式没有指定架构例如arm64架构clang -rewrite-objc main.m -o main.cpp// 或使用 xcrun 指定架构xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp OC 代码如下： 12345678910#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *objc = [[NSObject alloc] init]; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 使用 xcrun 转换为 cpp 文件后，我们可以找到 NSObject_IMPL 结构体，其代码如下： 123struct NSObject_IMPL &#123; Class isa;&#125;; 1typedef struct objc_class *Class; 2. OC 对象、类的本质是什么？根据上述转换结果，我们可以发现 Class 的本质其实是一个指针 OC 对象、类其实是基于 c\\c++ 结构体实现的。 3. OC 对象在内存中的布局，一个 NSObject 对象占多少内存？NSObject 转换为 c 语言其实就是一个结构体，如上的 NSObject_IMPL ，该结构体的成员只有一个 isa 指针，在 64 位架构中一个指针占 8 个字节，也就是说一个 NSObject 对象所占的内存是 8 个字节。 但是我们真的可以认为一个 NSObject 对象就占用 8 个字节吗？ 我们可使用如下方法进行验证：方式一： 12// 打印信息 8和16NSLog(@&quot;%zd,%zd&quot;, class_getInstanceSize([NSObject class]) ,class_getInstanceSize([Student class])); 方式二： 实时查看内存数据：打断点 -&gt; Debug Workflow -&gt; viewMemory address -&gt; 输入 stu 对象的地址 方式三： 通过 lldb 指令 1234567891011121314memory read 0x10074c450// 简写 x 0x10074c450// 增加读取条件// memory read/数量格式字节数 内存地址// 简写 x/数量格式字节数 内存地址// 格式 x是16进制，f是浮点，d是10进制// 字节大小 b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节示例：x/4xw // /后面表示如何读取数据 w表示4个字节4个字节读取，x表示以16进制的方式读取数据，4则表示读取4次// 同时可以修改值//将_no的值改为了6memory write 0x100400c68 6 表面上如此，但实际上一个 NSObject 实例对象的大小确实为8个字节，但是系统给其分配的内存其实是16个字节。可以通过objc4源码来探究一下为什么。 搜索 class_getInstanceSize 方法 12345size_t class_getInstanceSize(Class cls)&#123; if (!cls) return 0; return cls-&gt;alignedInstanceSize();&#125; 我们会发现这个方法返回值是cls-&gt;alignedInstanceSize() 12345// Class&apos;s ivar size rounded up to a pointer-size boundary.// 注释意思：返回值成员变量的占用内存大小uint32_t alignedInstanceSize() &#123; return word_align(unalignedInstanceSize());&#125; 我们继续看下 malloc_size，由于苹果部分源码不公开，不过不影响今天讨论内容，我们先 malloc.h 文件中函数声明： 123/* Returns size of given ptr */// 注释意思：返回分配给指针的占用内存大小extern size_t malloc_size(const void *ptr); 总结：通过阅读源码，发现一个 NSObject 对象，系统给其分配的空间为 16 个字节，只不过其真正利用起来的只有 8 个字节。 1NSObject *obj = [[NSObject alloc] init]; 上面这行代码，可以发现，创建一个新的实例对象，分为两步： alloc: 分配内存空间init: 初始化 所以，我们想探究实质的话可以从 alloc 方法往里面查看，从 alloc 开始搜索的话太多了，我们直接从 allocWithZone 开始查看 12345678910111213141516171819202122232425262728293031323334+ (id)allocWithZone:(struct _NSZone *)zone &#123; return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);&#125;//allocWithZone 调用的是: _objc_rootAllocWithZoneid _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)&#123; id obj; /* 为了更方便理解，将部分代码省略 */ obj = class_createInstance(cls, 0); return obj;&#125;//_objc_rootAllocWithZone 分配内存空间其实是: class_createInstanceid class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125;// 继续查找...static __attribute__((always_inline)) id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)&#123; /* 为了更方便理解，将部分代码省略 */ size_t size = cls-&gt;instanceSize(extraBytes); id obj; obj = (id)calloc(1, size); return obj;&#125; 关键位置： 123456789101112// Class&apos;s ivar size rounded up to a pointer-size boundary.uint32_t alignedInstanceSize() &#123; return word_align(unalignedInstanceSize());&#125;size_t instanceSize(size_t extraBytes) &#123; // 如果是 NSObject ，下面这行代码相当于 size_t size = 8; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size;&#125; 通过注释和代码可以发现，CF：CoreFoundation，硬性规定，返回 size 最小为16。这是为什么呢，因为苹果设计 CF 框架，包括我们自己设计一套框架，为了我们的框架能够更好的运行，肯定会做出一些规定、约束，这样就可以理解了。至于 word_align，与 内存对齐 有关。 4. 自定义类的内部实现123456789101112131415161718192021@interface Student : NSObject&#123; @public int _no; int _age;&#125;@end@implementation Studentint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Student *stu = [[Student alloc] init]; stu -&gt; _no = 4; stu -&gt; _age = 5; NSLog(@&quot;%@&quot;,stu); &#125; return 0;&#125;@end 同样转换为 c++ 文件，得到 Student_IMPL： 12345struct Student_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; int _no; int _age;&#125;; 发现第一个是 NSObject_IMPL 的实现，由于其内部就是 Class isa;，那么我们假设 struct NSObject_IMPL NSObject_IVARS; 可以等价于 Class isa; 。因此可知创建 Student 对象首先会分配 16 个字节，isa 8 _no 4 _age 4 。 从另外一个角度，其实还有 内存对齐 这个概念，就算是没有 OC 对象至少占用 16 个字节这个规定， Student_IMPL 也占用 16 个字节，内存对齐有一条规定：结构体的大小比必须是最大成员大小的倍数。 5. 更复杂的继承关系123456789101112131415161718192021222324252627282930/* Person */@interface Person : NSObject&#123; int _age;&#125;@end@implementation Person@end/* Student */@interface Student : Person&#123; int _no;&#125;@end@implementation Student@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;%zd %zd&quot;, class_getInstanceSize([Person class]), class_getInstanceSize([Student class]) ); &#125; return 0;&#125; 我们发现只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。其实实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 我们可以总结内存对齐为两个原则： 前面的地址必须是后面的地址正数倍,不是就补齐。 整个Struct的地址必须是最大字节的整数倍。 6. OC对象的分类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;/* Person */ @interface Person : NSObject &lt;NSCopying&gt;&#123; @public int _age;&#125;@property (nonatomic, assign) int height;- (void)personMethod;+ (void)personClassMethod;@end@implementation Person- (void)personMethod &#123;&#125;+ (void)personClassMethod &#123;&#125;@end/* Student */@interface Student : Person &lt;NSCoding&gt;&#123; @public int _no;&#125;@property (nonatomic, assign) int score;- (void)studentMethod;+ (void)studentClassMethod;@end@implementation Student- (void)studentMethod &#123;&#125;+ (void)studentClassMethod &#123;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *object1 = [[NSObject alloc] init]; NSObject *object2 = [[NSObject alloc] init]; Student *stu = [[Student alloc] init]; [Student load]; Person *p1 = [[Person alloc] init]; p1-&gt;_age = 10; [p1 personMethod]; [Person personClassMethod]; Person *p2 = [[Person alloc] init]; p2-&gt;_age = 20; &#125; return 0;&#125; OC对象主要可以分为三种： instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） 实例对象instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象 12NSObjcet *object1 = [[NSObjcet alloc] init];NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。instance对象在内存中存储的信息包括： isa 指针 其他成员变量 在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？那么类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ 12345678Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = [NSObject class];// runtimeClass objectClass4 = object_getClass(object1);Class objectClass5 = object_getClass(object2);NSLog(@&quot;%p %p %p %p %p&quot;, objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); class对象:我们通过class方法或 runtime 方法得到一个 class 对象。class 对象也就是类对象。每一个类在内存中有且只有一个 class 对象。 class 对象在内存中存储的信息主要包括： isa 指针 superclass 指针 类的属性信息（@property），类的成员变量信息（ivar） 类的对象方法信息（instance method），类的协议信息（protocol） 成员变量的值是存储在实例对象中的。 因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。所以存储在 class 对象中。 元类对象 meta-class：1234567//runtime中传入类对象此时得到的就是元类对象Class objectMetaClass = object_getClass([NSObject class]);// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象Class cls = [[NSObject class] class];Class objectClass3 = [NSObject class];class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象NSLog(@&quot;%p %p %p&quot;, objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个 meta-class 对象。meta-class 对象和 class 对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 isa指针 superclass指针 类的类方法的信息（class method） meta-class 对象和 class 对象的内存结构是一样的，所以 meta-class 中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 对象的isa指针指向哪里： 当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 1[stu studentMethod]; instance 的 isa 指向 class ，当调用对象方法时，通过 instance 的 isa 找到 class ，最后找到对象方法的实现进行调用。 当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象。 1[Student studentClassMethod]; class 的 isa 指向 meta-class当调用类方法时，通过 class 的 isa 找到 meta-class ，最后找到类方法的实现进行调用 当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到 class 类对象 superclass 指针。 12[stu personMethod];[stu init]; 当 Student 的 instance 对象要调用 Person 的对象方法时，会先通过 isa 找到 Student 的 class ，然后通过 superclass 找到 Person 的 class ，最后找到对象方法的实现进行调用，同样如果 Person 发现自己没有响应的对象方法，又会通过 Person 的 superclass 指针找到 NSObject 的 class 对象，去寻找响应的方法 当类对象调用父类的类方法时，就需要先通过 isa 指针找到 meta-class ，然后通过 superclass 去寻找响应的方法 12[Student personClassMethod];[Student load]; 当 Student 的 class 要调用 Person 的类方法时，会先通过 isa 找到 Student 的 meta-class ，然后通过 superclass 找到 Person 的 meta-class ，最后找到类方法的实现进行调用 instance 的 isa 指向 class class 的 isa 指向 meta-class meta-class 的 isa 指向基类的 meta-class ，基类的 isa 指向自己 class 的 superclass 指向父类的 class ，如果没有父类，superclass 指针为 nil meta-class 的 superclass 指向父类的meta-class ，基类的 meta-class 的 superclass 指向基类的 class instance 调用对象方法的轨迹，isa 找到class ，方法不存在，就通过 superclass 找父类 class 调用类方法的轨迹，isa 找 meta-class ，方法不存在，就通过 superclass 找父类 7. 总结： 一个 NSObject 对象占用多少内存？一个指针变量所占用的大小（64bit 占 8 个字节，32bit 占 4 个字节) 实际因为内存对齐，系统(64位)为对象分配的内存大小为16个字节。 对象的 isa 指针指向哪里？instance 对象的 isa 指针指向 class 对象， class 对象的 isa 指针指向 meta-class 对象，meta-class 对象的 isa 指针指向基类的 meta-class 对象，基类自己的 isa 指针也指向自己。 OC 的类信息存放在哪里？成员变量的具体值存放在 instance 对象。对象方法，协议，属性，成员变量信息存放在 class 对象。类方法信息存放在 meta-class 对象。","categories":[],"tags":[]},{"title":"使用Core ML开发应用","slug":"使用Core-ML开发应用","date":"2019-04-03T08:53:52.000Z","updated":"2019-04-04T08:16:02.740Z","comments":true,"path":"2019/04/03/使用Core-ML开发应用/","link":"","permalink":"http://yoursite.com/2019/04/03/使用Core-ML开发应用/","excerpt":"Core ML 是苹果在 WWDC 2017 中发布的一款机器学习的框架。通过使用这款框架，哪怕我们并不了解神经网络和机器学习的相关知识，我们仍然可以轻松的为我们的 App 添加机器学习的能力，并且无需专用服务器，通过使用 Mac 即可从自定义的数据中训练 Apple 的模型。","text":"Core ML 是苹果在 WWDC 2017 中发布的一款机器学习的框架。通过使用这款框架，哪怕我们并不了解神经网络和机器学习的相关知识，我们仍然可以轻松的为我们的 App 添加机器学习的能力，并且无需专用服务器，通过使用 Mac 即可从自定义的数据中训练 Apple 的模型。 1.获取模型 首先我们需要一个已经训练好的 Core ML 模型，可通过 官网下载 已经训练好的模型进行使用，目前官网上已有下列模型可供选择，本文样例中使用的是 MobileNet ： MobileNetMobileNets基于简化的体系结构，具有深度可分离的卷积，以构建轻量级，深度神经网络。从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 SqueezeNet从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。SqueezeNet的总体占用空间仅为5 MB，其精度与AlexNet相似，但参数减少了50倍。 Places205-GoogLeNet从205个类别中检测图像的场景，例如机场航站楼，卧室，森林，海岸等。 ResNet50从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 Inception v3从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 VGG16从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 2.搭建界面打开 Xcode (本文使用的是 Xcode10.2 swift4.2)，新建一个项目，选择 Single View App ，然后实现如下界面： 实现 打开相机 和 打开图库 的功能，并在 info.plist 文件中添加相应的权限说明。 代码如下： 1234567891011121314151617181920212223/// 打开相机进行拍照@IBAction func capturePhoto(_ sender: Any) &#123; if (!UIImagePickerController.isSourceTypeAvailable(.camera)) &#123; self.alert(msg: &quot;抱歉，无法使用相机！&quot;) return &#125; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .camera cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil) &#125; /// 打开图库选取图片@IBAction func openPhotoLibrary(_ sender: Any) &#123; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .photoLibrary cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil) &#125; 另外需要实现代理方法来获得获取的图片，代理方法如下： 12345678910111213141516// MARK: - UIImagePickerControllerDelegateextension ViewController: UIImagePickerControllerDelegate &#123; func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125; func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; picker.dismiss(animated: true, completion: nil) guard let img = info[UIImagePickerController.InfoKey.originalImage] as? UIImage else &#123; return &#125; analyzingImage(img: img) &#125;&#125; 3.添加模型文件在项目中新建一个 Model 目录，并将下载好的 Core ML 模型文件加入到该目录中，如下图： 然后就可以在 Xcode 中查看该模型的详细信息了： 由此我们可以知道，模型 MobileNet 需要的输入为 224x224 大小的图片数据，输出的结果是图片最有可能属于的类别和所有可能类别的概率，且该模型会自动生成名称为 MobileNet 的 Swift 模型类文件，且可以通过点击模型文件信息中 Model Class 属性的箭头查看模型类文件的详细信息。 4.处理输入数据由上个步骤，我们知道模型 MobileNet 需要的是大小为 224x224 的图片输入，因此在使用该模型前我们需要对我们获取的图片进行一些处理，如果输入图片不符合该条件，那么在处理的时候将会报错，且我们也无法获取到模型预测的结果。 转换图片的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/// 调整图片大小////// - Parameters:/// - size: 图片大小/// - block: 回调（获取调整后的UIImage对象和像素图片数据）func resize(size:CGSize, block:ResizePixelBufferBlock) -&gt; Void &#123; UIGraphicsBeginImageContextWithOptions(size, true, UIScreen.main.scale) draw(in: CGRect.init(origin: CGPoint.zero, size: size)) let newImg = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() let attrs = [ kCVPixelBufferCGImageCompatibilityKey:kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey:kCFBooleanTrue, ] as CFDictionary var pixelBuffer : CVPixelBuffer? let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImg.size.width), Int(newImg.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer) guard kCVReturnSuccess == status, let pBuffer = pixelBuffer else &#123; print(&quot;转换失败!&quot;) block(nil,nil) return &#125; CVPixelBufferLockBaseAddress(pBuffer, CVPixelBufferLockFlags.init(rawValue: 0)) let pixelData = CVPixelBufferGetBaseAddress(pBuffer) let rgbColorSpace = CGColorSpaceCreateDeviceRGB() let context = CGContext(data: pixelData, width: Int(newImg.size.width), height: Int(newImg.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pBuffer), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue) context?.translateBy(x: 0, y: newImg.size.height) context?.scaleBy(x: 1.0, y: -1.0) guard nil != context else &#123; print(&quot;转换失败!&quot;) block(nil,nil) return &#125; UIGraphicsPushContext(context!) newImg.draw(in: CGRect(origin: CGPoint.zero, size: newImg.size)) UIGraphicsPopContext() CVPixelBufferUnlockBaseAddress(pBuffer, CVPixelBufferLockFlags(rawValue: 0)) block(newImg,pBuffer) &#125; 5.使用模型文件使用方法非常简单，代码如下： 1234567891011121314151617/// 分析获取到的图片func analyzingImage(img:UIImage) &#123; let size = CGSize(width: 224.0, height: 224.0) img.resize(size: size, block: &#123; (img, pixelBuffer) in imageView.image = img guard let pBuffer = pixelBuffer else &#123; return &#125; // 创建模型的对象 let model:MobileNet = MobileNet() guard let mobileOutput = try? model.prediction(image: pBuffer) else &#123; return &#125; infoLabel.text = &quot;\\(mobileOutput.classLabel)&quot; &#125;)&#125; 然后就获取到使用模型预测的结果了，最终效果图如下：","categories":[],"tags":[]},{"title":"PlistBuddy的基本使用","slug":"PlistBuddy的基本使用","date":"2018-11-16T09:47:44.000Z","updated":"2018-11-19T10:07:19.000Z","comments":true,"path":"2018/11/16/PlistBuddy的基本使用/","link":"","permalink":"http://yoursite.com/2018/11/16/PlistBuddy的基本使用/","excerpt":"PlistBuddy是Mac自带的用于解析plist文件的工具，通过这个工具我们可以实现在终端中读写plist文件。","text":"PlistBuddy是Mac自带的用于解析plist文件的工具，通过这个工具我们可以实现在终端中读写plist文件。 1.查看帮助该工具需要使用绝对路径来引用，查看命令帮助方式如下： 1/usr/libexec/PlistBuddy --help 终端将会打印出该工具的命令介绍，如下图所示： 2.简单使用1.打印打印plist文件信息可以使用如下命令： 1/usr/libexec/PlistBuddy -c &quot;print&quot; 1.plist 如果需要打印指定字段或者指定索引的值可以参考如下命令方式，打印根Array第0个元素Dictionary的title字段： 1/usr/libexec/PlistBuddy -c &quot;print :0:title&quot; 1.plist 2.添加如下所示命令为向根Array第0个元素Dictionary中添加字段为version，值为1.0的数据： 1/usr/libexec/PlistBuddy -c &quot;Add :0:version string 1.0&quot; 1.plist 添加后的结果如下图： 如果需要添加一个Array类型的数据或者Dictionary类型的数据可以用以下命令先行创建Array或者Dictionary类型的数据后再向其中添加值： 1234# 添加Array数据/usr/libexec/PlistBuddy -c &apos;Add :2 Array&apos; 1.plist# 添加Dictionary类型数据/usr/libexec/PlistBuddy -c &apos;Add :3 dict&apos; 1.plist 添加后的结果如下图： 3.删除如下所示命令为删除根Array中的第2个元素 1/usr/libexec/PlistBuddy -c &apos;Delete :2&apos; 1.plist 删除后的结果如下图所示： 如下所示命令为删除根Array中第0个元素Dictionary中的字段为number的数据： 1/usr/libexec/PlistBuddy -c &apos;Delete :0:number&apos; 1.plist 删除后结果如下图所示： 4.修改如下所示命令为修改Array第0个元素Dictionary中的字段为version的数据： 1/usr/libexec/PlistBuddy -c &apos;Set :0:version &quot;2.0&quot;&apos; 1.plist 修改后结果如下图所示： 5.合并使用如下命令合并1.plist到2.plist文件中 1/usr/libexec/PlistBuddy -c &apos;Merge 1.plist&apos; 2.plist 合并前与合并后的文件内容如下图所示：","categories":[],"tags":[]},{"title":"Mac终端压缩解压命令收集","slug":"Mac终端压缩解压命令收集","date":"2018-11-02T01:52:19.000Z","updated":"2018-11-02T02:11:05.000Z","comments":true,"path":"2018/11/02/Mac终端压缩解压命令收集/","link":"","permalink":"http://yoursite.com/2018/11/02/Mac终端压缩解压命令收集/","excerpt":"本文收集了一些Mac终端下常用的压缩解压文件命令，以供查阅。","text":"本文收集了一些Mac终端下常用的压缩解压文件命令，以供查阅。 tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -———————————————.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.压缩：sEx a FileName. FileName sEx只是调用相关程序，本身并无压缩、解压功能，请注意！gzip 命令减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。语法：gzip [选项] 压缩（解压缩）的文件名该命令的各选项含义如下：-c 将输出写到标准输出上，并保留原有文件。-d 将压缩文件解压。-l 对每个压缩文件，显示下列字段： 压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。-t 测试，检查压缩文件是否完整。-v 对每一个压缩和解压的文件，显示文件名和压缩比。-num 用指定的数字 num 调整压缩的速度，-1 或 –fast 表示最快压缩方法（低压缩比），-9 或–best表示最慢压缩方法（高压缩比）。系统缺省值为 6。指令实例：gzip % 把当前目录下的每个文件压缩成 .gz 文件。gzip -dv % 把当前目录下每个压缩的文件解压，并列出详细的信息。gzip -l *% 详细显示例1中每个压缩的文件的信息，并不解压。gzip usr.tar% 压缩 tar 备份文件 usr.tar，此时压缩文件的扩展名为.tar.gz。","categories":[],"tags":[]},{"title":"搭建cocoapods私有库","slug":"搭建cocoapods私有库","date":"2018-10-29T07:55:02.000Z","updated":"2019-03-25T06:51:37.084Z","comments":true,"path":"2018/10/29/搭建cocoapods私有库/","link":"","permalink":"http://yoursite.com/2018/10/29/搭建cocoapods私有库/","excerpt":"Cocoapods 是一款swift和Objective-C项目的依赖管理工具，使用Cocoapods我们可以很方便的管理项目中的依赖库，本文将会介绍Cocoapods私有库的创建和使用。","text":"Cocoapods 是一款swift和Objective-C项目的依赖管理工具，使用Cocoapods我们可以很方便的管理项目中的依赖库，本文将会介绍Cocoapods私有库的创建和使用。 1.创建创建版本库使用GitHub或者码云创建一个新的远程Git仓库，创建好仓库后使用终端命令将该仓库添加到本地的版本仓库配置中，配置方式如下: 1pod repo add RepoName url 其中RepoName为私有库的名字(自行命名)，url 为创建的仓库的地址。创建好之后在Finder下查看目录~/.cocoapods/repo 可以查看到私有库名称对应的文件夹，并且在终端使用如下命令可以查看到Cocoapods的仓库配置列表中已经存在我们自己创建的私有库配置： 1pod repo list 如需移除多余的库可以使用如下命令 1pod repo remove RepoName 创建代码库同样新建一个远程的Git仓库，同时添加好License文件和README文件，将自己的代码添加并推送到该远程仓库，使用如下命令创建pod描述文件： 1pod spec create &lt;LibName&gt; 命令中的LibName替换成自己私有组件或模块的名称，podspec文件参考如下模板进行配置: 12345678910111213Pod::Spec.new do |s| s.name = &apos;LibName&apos; s.version = &apos;0.0.1&apos; s.summary = &apos;Lib描述&apos; s.license = &#123;:type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot;&#125; s.homepage = &quot;代码仓库主页的地址&quot; s.authors = &#123; &apos;test&apos; =&gt; &apos;test@qq.com&apos; &#125; #作者信息 s.source = &#123; :git =&gt; &quot;https://test.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; #仓库地址 s.source_files = &apos;Lib/*.&#123;h,m&#125;&apos; #代码位置 s.ios.deployment_target = &apos;8.0&apos; #支持的iOS版本 s.frameworks = &quot;UIKit&quot; #需要使用的框架 s.dependency &quot;Masonry&quot; #依赖的第三方 end 然后使用如下命令验证podspec文件配置是否正确。 1234# 本地验证pod lib lint LibName.podspec# 远程验证pod spec lint LibName.podspec 如有错误，根据提示修改，或者参数 --allow-warnings 或 --use-libraries 进行尝试。 验证通过后可以使用如下命令推送到私有库中 1pod repo push RepoName LibName.podspec 2.使用在Podfile文件中添加上如下配置 1234567# Cocoapods官方库地址source &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;私有库地址&apos; target &apos;targetName&apos; do pod &apos;私有库名称&apos;end 然后使用 install 命令 或者 update 命令进行操作就可以使用了。","categories":[],"tags":[]},{"title":"使用Hexo搭建自己的博客","slug":"使用Hexo搭建自己的博客","date":"2018-09-26T12:23:39.000Z","updated":"2018-10-29T06:44:56.000Z","comments":true,"path":"2018/09/26/使用Hexo搭建自己的博客/","link":"","permalink":"http://yoursite.com/2018/09/26/使用Hexo搭建自己的博客/","excerpt":"Hexo 是基于Node.js的一款快速、间接且高效的博客框架，支持Markdown，可更换主题，拥有丰富的插件，使用非常方便。","text":"Hexo 是基于Node.js的一款快速、间接且高效的博客框架，支持Markdown，可更换主题，拥有丰富的插件，使用非常方便。 Hexo官网 准备 Node.js Hexo Git GitHub账号 安装Node.js 点击 链接 到Node.js官网下载对应平台的安装程序即可安装。 安装Hexo 所有必备的应用程序安装完成后，即可使用npm安装Hexo。 1npm install -g hexo-cli 安装Git Windows下载并安装 Git Mac使用Homebrew：brew install git ；或下载 安装程序 安装。 配置GitHub仓库 注册一个 GitHub 账号 创建一个GitHub仓库新仓库名使用 “UserName”+“github.io” 的格式命名，之后访问的域名就会是 https://UserName.github.io 的形式 开启GitHub Page服务在仓库的 Settings 中找到 GitHub Pages 配置，并点击 Choose a theme 任意选择一个主题，此时会跳转到仓库，然后我们再查看 Settings 就可以看见开启 GitHub Pages 之后得到的域名，就可以使用该域名进行访问了 开始使用Hexo1.建立本地站点 首先在你想要用于存放站点的目录位置使用如下命令： 1hexo init &lt;folder&gt; 新建完成后，指定文件夹的目录如下 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 文件为站点的配置信息文件，可以用于修改一些网站参数，详细的配置参数可以参考Hexo官网的 文档。 package.json文件为站点的依赖配置文件，EJS，Stylus 和 Markdown render 已默认安装。 scaffolds为模板文件夹，当您新建文章时，Hexo会根据scaffold来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source为用户资源存放文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes为主题文件夹，用于存放Hexo的主题文件，Hexo 会根据主题来生成静态页面。 2.启用本地站点使用如下命令生成静态文件 1hexo generate 该命令可以使用如下参数 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 使用如下命令启动服务器。默认情况下，访问网址为：http://localhost:4000 。 1hexo server 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 3.关联GitHub编辑本地hexo目录下的_config.yml文件下的deploy配置，设置部署位置，如下： 12345deploy: type: git repository: &lt;repository url&gt; branch: [branch] message: [message] 参数 描述 repo 库（Repository）地址 branch 分支名称。如果您使用的是 GitHub 或者 GitCafe 的话，程序会尝试自动检测。 message 自定义提交信息（默认为 Site updated: YYYY-MM-DD HH:mm:ss） 然后可使用如下命令开始部署 1hexo deploy 参数 描述 -g, --generate 部署之前预先生成静态文件 部署完成后就可以使用 https://UserName.github.io 进行访问查看效果了。 4.新建一篇博客 使用如下命令新建一篇博客： 1hexo new post &quot;博客文章名&quot; 在生成及部署文章之前需要安装一个扩展，使用如下命令进行安装： 1npm install hexo-deployer-git --save 使用编辑器编辑好文章后使用命令：hexo d -g 生成并部署，完成之后使用 https://UserName.github.io 访问就可以查看到新生成的文章了。 5.更换主题首先在Hexo的官方 主题市场 中找到自己喜欢的主题，点击选中的主题进入到主题的GitHub仓库，复制主题仓库的地址，找到Hexo在本地的主目录(步骤1中存放的位置)，使用如下命令克隆主题文件： 1git clone &lt;repository url&gt; themes/&lt;主题名&gt; 或者进入Hexo主目录下的themes目录，将主题文件克隆至该目录下。注意： 部分主题可能需要安装插件，可以参考相应主题的说明文档进行设置。下载好主题的文件后需要修改Hexo的配置文件_config.yml (该文件存放于Hexo的主目录下)。修改其中的theme字段信息，参考如下： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 然后使用如下命令清楚缓存、重新生成、启动网站就可以看到效果了 123hexo cleanhexo ghexo s","categories":[],"tags":[]},{"title":"使用Jenkins+fastlane进行持续集成","slug":"使用Jenkins-fastlane进行持续集成","date":"2018-07-12T10:20:05.000Z","updated":"2018-10-29T06:44:56.000Z","comments":true,"path":"2018/07/12/使用Jenkins-fastlane进行持续集成/","link":"","permalink":"http://yoursite.com/2018/07/12/使用Jenkins-fastlane进行持续集成/","excerpt":"Jenkens是由Java语言开发的一个持续集成工具，使用Jenkins+fastlane可以帮助我们快速搭建一个iOS持续集成的环境。","text":"Jenkens是由Java语言开发的一个持续集成工具，使用Jenkins+fastlane可以帮助我们快速搭建一个iOS持续集成的环境。 1.新建任务在Jenkins中使用新建任务功能，设定好任务名称，并使用构建一个自由风格的软件项目方式创建一个任务 2.配置任务信息设置任务的描述；设置丢弃旧的构建，使用默认的策略方式即可，“保存构建的天数“ 和 ”保持构建的最大个数“可根据个人需求进行配置。 配置任务的Git地址、访问Git的凭证(账号密码或者使用SSH)、使用的分支 3.设置构建触发器定时构建： 一般设置为H 20 (注意使用空格分隔) 每天20点定时执行轮询 SCM：需要设置源码路径才能起到轮询的效果，一般设置为 H/5 * (注意使用空格分隔) 每5分钟轮询一次 4设置构建方式在构建设置中使用增加构建步骤添加执行shell方式来进行构建，此处为了简化构建命令设置，已事先在项目中集成fastlane，fastlane的集成方式可以参考链接使用的shell脚本如下 1234567#!/bin/bash#切换到项目目录cd DDKanQiu#执行pod更新依赖pod update --no-repo-update#使用fastlane打包命令fastlane beta 注意：使用shell脚本时，请提前配置好Jenkins的环境变量，可以使用如下命令获取当前系统的环境变量1echo $PATH 通过Jenkins的 系统管理 - 系统设置 - 全局属性 - 环境变量 进行设置，点击增加，增加环境变量配置 至此，任务的配置已经完成了，可以保存设置并立即开始构建了。可以通过构建记录查询构建的状态，如果构建失败，可以通过控制台输出查看log输出查找失败原因，有时可能因为一些环境配置的不正确导致构建失败，耐心检查控制台输出可能有助于你快速找到问题原因。另外，由于之前直接使用Mac平台的pkg安装包安装Jenkins，Jenkins会在系统的用户目录的共享目录下创建Jenkins的工作目录，Jenkins拉取的项目代码也会存于此路径下，这种情况可能由于MacOS的权限限制导致部分项目管理工具无法正常运行(例如我在使用过程中发现cocoapods无法正常工作)，网上说是需要将Jenkins的用户设置为root用户(我没有测试过)。为此，我改用了Tomcat+Jenkins的war包的方式重新部署了Jenkins并解决了问题。","categories":[],"tags":[]},{"title":"fastlane集成与使用","slug":"fastlane集成与使用","date":"2018-05-19T10:21:10.000Z","updated":"2018-10-29T06:44:56.000Z","comments":true,"path":"2018/05/19/fastlane集成与使用/","link":"","permalink":"http://yoursite.com/2018/05/19/fastlane集成与使用/","excerpt":"fastlane 是一款使用ruby开发的自动化工具集，使用它可以简化我们部署项目的过程，实现自动化部署，提高工作效率。","text":"fastlane 是一款使用ruby开发的自动化工具集，使用它可以简化我们部署项目的过程，实现自动化部署，提高工作效率。 GitHub 1.环境安装1.确定ruby是否安装，使用ruby -v 查看ruby版本1ruby -v 2.安装Xcode命令行工具，使用如下命令进行安装1xcode-select --install 如果出现1xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 代表已安装，否则根据提示进行操作即可安装 3.安装fastlane，使用如下命令进行安装，安装需要一点等待时间1sudo gem install fastlane 2.使用fastlane打包并上传到蒲公英1.安装蒲公英插件，在终端中输入如下命令进行安装1fastlane add_plugin pgyer 出现如下信息说明安装成功 2.初始化切换到Xcode工程目录下面，使用如下命令进行初始化1fastlane init 初始化过程中会出现以下选项，目前使用的是第4个选项12345[15:52:35]: What would you like to use fastlane for?1. 📸 Automate screenshots2. 👩‍✈️ Automate beta distribution to TestFlight3. 🚀 Automate App Store distribution4. 🛠 Manual setup - manually setup your project to automate your tasks 12341.自动截屏(暂未使用)2.自动发布测试版本到 TestFlight3.自动发布到App Store4.手动配置 初始过程中会出现一些提示，根据提示信息一直按Enter键就好了，初始完成后的打印信息如下 1234567891011121314[16:03:36]: ------------------------------[16:03:36]: --- Where to go from here? ---[16:03:36]: ------------------------------[16:03:36]: 📸 Learn more about how to automatically generate localized App Store screenshots:[16:03:36]: https://docs.fastlane.tools/getting-started/ios/screenshots/[16:03:36]: 👩‍✈️ Learn more about distribution to beta testing services:[16:03:36]: https://docs.fastlane.tools/getting-started/ios/beta-deployment/[16:03:36]: 🚀 Learn more about how to automate the App Store release process:[16:03:36]: https://docs.fastlane.tools/getting-started/ios/appstore-deployment/[16:03:36]: 👩‍⚕️ Learn more about how to setup code signing with fastlane[16:03:36]: https://docs.fastlane.tools/codesigning/getting-started/[16:03:36]: [16:03:36]: To try your new fastlane setup, just enter and run[16:03:36]: $ fastlane custom_lane 初始化完成后会在项目目录下生成一些文件，如下图 3.设置配置文件 Fastfile然后，找到在用的工作流（action），在 build_app 指令后，加入蒲公英插件的配置信息1234lane :beta do build_app(export_method: &quot;ad-hoc&quot;) pgyer(api_key: &quot;7f15xxxxxxxxxxxxxxxxxx141&quot;, user_key: &quot;4a5bcxxxxxxxxxxxxxxx3a9e&quot;)end 注意： 以上的 api_key 和 user_key，在自己账号下的 应用管理 - App概述 - API 中可以找到，并替换到以上相应的位置。 在 Xcode 8.3 和 Xcode 8.3 以后的版本中，对于 build_app 的 export_method 的值，需要根据开发者的打包类型进行设置，可选的值有：app-store、ad-hoc、development、enterprise。对于 Xcode 8.3 以下的版本，则不需要设置 export_method。 4.完成以上配置后在终端中输入以下命令就可以使用了1fastlane beta","categories":[],"tags":[]}]}