{"meta":{"title":"白云心城的博客","subtitle":null,"description":null,"author":"白云心城","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"使用Core ML开发应用","slug":"使用Core-ML开发应用","date":"2019-04-03T08:53:52.000Z","updated":"2019-04-04T08:16:02.740Z","comments":true,"path":"2019/04/03/使用Core-ML开发应用/","link":"","permalink":"http://yoursite.com/2019/04/03/使用Core-ML开发应用/","excerpt":"Core ML 是苹果在 WWDC 2017 中发布的一款机器学习的框架。通过使用这款框架，哪怕我们并不了解神经网络和机器学习的相关知识，我们仍然可以轻松的为我们的 App 添加机器学习的能力，并且无需专用服务器，通过使用 Mac 即可从自定义的数据中训练 Apple 的模型。","text":"Core ML 是苹果在 WWDC 2017 中发布的一款机器学习的框架。通过使用这款框架，哪怕我们并不了解神经网络和机器学习的相关知识，我们仍然可以轻松的为我们的 App 添加机器学习的能力，并且无需专用服务器，通过使用 Mac 即可从自定义的数据中训练 Apple 的模型。 1.获取模型 首先我们需要一个已经训练好的 Core ML 模型，可通过 官网下载 已经训练好的模型进行使用，目前官网上已有下列模型可供选择，本文样例中使用的是 MobileNet ： MobileNetMobileNets基于简化的体系结构，具有深度可分离的卷积，以构建轻量级，深度神经网络。从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 SqueezeNet从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。SqueezeNet的总体占用空间仅为5 MB，其精度与AlexNet相似，但参数减少了50倍。 Places205-GoogLeNet从205个类别中检测图像的场景，例如机场航站楼，卧室，森林，海岸等。 ResNet50从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 Inception v3从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 VGG16从一组1000个类别（例如树木，动物，食物，车辆，人员等）中检测图像中存在的主要对象。 2.搭建界面打开 Xcode (本文使用的是 Xcode10.2 swift4.2)，新建一个项目，选择 Single View App ，然后实现如下界面： 实现 打开相机 和 打开图库 的功能，并在 info.plist 文件中添加相应的权限说明。 代码如下： 1234567891011121314151617181920212223/// 打开相机进行拍照@IBAction func capturePhoto(_ sender: Any) &#123; if (!UIImagePickerController.isSourceTypeAvailable(.camera)) &#123; self.alert(msg: &quot;抱歉，无法使用相机！&quot;) return &#125; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .camera cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil) &#125; /// 打开图库选取图片@IBAction func openPhotoLibrary(_ sender: Any) &#123; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .photoLibrary cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil) &#125; 另外需要实现代理方法来获得获取的图片，代理方法如下： 12345678910111213141516// MARK: - UIImagePickerControllerDelegateextension ViewController: UIImagePickerControllerDelegate &#123; func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125; func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; picker.dismiss(animated: true, completion: nil) guard let img = info[UIImagePickerController.InfoKey.originalImage] as? UIImage else &#123; return &#125; analyzingImage(img: img) &#125;&#125; 3.添加模型文件在项目中新建一个 Model 目录，并将下载好的 Core ML 模型文件加入到该目录中，如下图： 然后就可以在 Xcode 中查看该模型的详细信息了： 由此我们可以知道，模型 MobileNet 需要的输入为 224x224 大小的图片数据，输出的结果是图片最有可能属于的类别和所有可能类别的概率，且该模型会自动生成名称为 MobileNet 的 Swift 模型类文件，且可以通过点击模型文件信息中 Model Class 属性的箭头查看模型类文件的详细信息。 4.处理输入数据由上个步骤，我们知道模型 MobileNet 需要的是大小为 224x224 的图片输入，因此在使用该模型前我们需要对我们获取的图片进行一些处理，如果输入图片不符合该条件，那么在处理的时候将会报错，且我们也无法获取到模型预测的结果。 转换图片的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/// 调整图片大小////// - Parameters:/// - size: 图片大小/// - block: 回调（获取调整后的UIImage对象和像素图片数据）func resize(size:CGSize, block:ResizePixelBufferBlock) -&gt; Void &#123; UIGraphicsBeginImageContextWithOptions(size, true, UIScreen.main.scale) draw(in: CGRect.init(origin: CGPoint.zero, size: size)) let newImg = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() let attrs = [ kCVPixelBufferCGImageCompatibilityKey:kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey:kCFBooleanTrue, ] as CFDictionary var pixelBuffer : CVPixelBuffer? let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImg.size.width), Int(newImg.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer) guard kCVReturnSuccess == status, let pBuffer = pixelBuffer else &#123; print(&quot;转换失败!&quot;) block(nil,nil) return &#125; CVPixelBufferLockBaseAddress(pBuffer, CVPixelBufferLockFlags.init(rawValue: 0)) let pixelData = CVPixelBufferGetBaseAddress(pBuffer) let rgbColorSpace = CGColorSpaceCreateDeviceRGB() let context = CGContext(data: pixelData, width: Int(newImg.size.width), height: Int(newImg.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pBuffer), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue) context?.translateBy(x: 0, y: newImg.size.height) context?.scaleBy(x: 1.0, y: -1.0) guard nil != context else &#123; print(&quot;转换失败!&quot;) block(nil,nil) return &#125; UIGraphicsPushContext(context!) newImg.draw(in: CGRect(origin: CGPoint.zero, size: newImg.size)) UIGraphicsPopContext() CVPixelBufferUnlockBaseAddress(pBuffer, CVPixelBufferLockFlags(rawValue: 0)) block(newImg,pBuffer) &#125; 5.使用模型文件使用方法非常简单，代码如下： 1234567891011121314151617/// 分析获取到的图片func analyzingImage(img:UIImage) &#123; let size = CGSize(width: 224.0, height: 224.0) img.resize(size: size, block: &#123; (img, pixelBuffer) in imageView.image = img guard let pBuffer = pixelBuffer else &#123; return &#125; // 创建模型的对象 let model:MobileNet = MobileNet() guard let mobileOutput = try? model.prediction(image: pBuffer) else &#123; return &#125; infoLabel.text = &quot;\\(mobileOutput.classLabel)&quot; &#125;)&#125; 然后就获取到使用模型预测的结果了，最终效果图如下：","categories":[],"tags":[]},{"title":"PlistBuddy的基本使用","slug":"PlistBuddy的基本使用","date":"2018-11-16T09:47:44.000Z","updated":"2018-11-19T10:07:19.000Z","comments":true,"path":"2018/11/16/PlistBuddy的基本使用/","link":"","permalink":"http://yoursite.com/2018/11/16/PlistBuddy的基本使用/","excerpt":"PlistBuddy是Mac自带的用于解析plist文件的工具，通过这个工具我们可以实现在终端中读写plist文件。","text":"PlistBuddy是Mac自带的用于解析plist文件的工具，通过这个工具我们可以实现在终端中读写plist文件。 1.查看帮助该工具需要使用绝对路径来引用，查看命令帮助方式如下： 1/usr/libexec/PlistBuddy --help 终端将会打印出该工具的命令介绍，如下图所示： 2.简单使用1.打印打印plist文件信息可以使用如下命令： 1/usr/libexec/PlistBuddy -c &quot;print&quot; 1.plist 如果需要打印指定字段或者指定索引的值可以参考如下命令方式，打印根Array第0个元素Dictionary的title字段： 1/usr/libexec/PlistBuddy -c &quot;print :0:title&quot; 1.plist 2.添加如下所示命令为向根Array第0个元素Dictionary中添加字段为version，值为1.0的数据： 1/usr/libexec/PlistBuddy -c &quot;Add :0:version string 1.0&quot; 1.plist 添加后的结果如下图： 如果需要添加一个Array类型的数据或者Dictionary类型的数据可以用以下命令先行创建Array或者Dictionary类型的数据后再向其中添加值： 1234# 添加Array数据/usr/libexec/PlistBuddy -c &apos;Add :2 Array&apos; 1.plist# 添加Dictionary类型数据/usr/libexec/PlistBuddy -c &apos;Add :3 dict&apos; 1.plist 添加后的结果如下图： 3.删除如下所示命令为删除根Array中的第2个元素 1/usr/libexec/PlistBuddy -c &apos;Delete :2&apos; 1.plist 删除后的结果如下图所示： 如下所示命令为删除根Array中第0个元素Dictionary中的字段为number的数据： 1/usr/libexec/PlistBuddy -c &apos;Delete :0:number&apos; 1.plist 删除后结果如下图所示： 4.修改如下所示命令为修改Array第0个元素Dictionary中的字段为version的数据： 1/usr/libexec/PlistBuddy -c &apos;Set :0:version &quot;2.0&quot;&apos; 1.plist 修改后结果如下图所示： 5.合并使用如下命令合并1.plist到2.plist文件中 1/usr/libexec/PlistBuddy -c &apos;Merge 1.plist&apos; 2.plist 合并前与合并后的文件内容如下图所示：","categories":[],"tags":[]},{"title":"Mac终端压缩解压命令收集","slug":"Mac终端压缩解压命令收集","date":"2018-11-02T01:52:19.000Z","updated":"2018-11-02T02:11:05.000Z","comments":true,"path":"2018/11/02/Mac终端压缩解压命令收集/","link":"","permalink":"http://yoursite.com/2018/11/02/Mac终端压缩解压命令收集/","excerpt":"本文收集了一些Mac终端下常用的压缩解压文件命令，以供查阅。","text":"本文收集了一些Mac终端下常用的压缩解压文件命令，以供查阅。 tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -———————————————.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.压缩：sEx a FileName. FileName sEx只是调用相关程序，本身并无压缩、解压功能，请注意！gzip 命令减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。语法：gzip [选项] 压缩（解压缩）的文件名该命令的各选项含义如下：-c 将输出写到标准输出上，并保留原有文件。-d 将压缩文件解压。-l 对每个压缩文件，显示下列字段： 压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。-t 测试，检查压缩文件是否完整。-v 对每一个压缩和解压的文件，显示文件名和压缩比。-num 用指定的数字 num 调整压缩的速度，-1 或 –fast 表示最快压缩方法（低压缩比），-9 或–best表示最慢压缩方法（高压缩比）。系统缺省值为 6。指令实例：gzip % 把当前目录下的每个文件压缩成 .gz 文件。gzip -dv % 把当前目录下每个压缩的文件解压，并列出详细的信息。gzip -l *% 详细显示例1中每个压缩的文件的信息，并不解压。gzip usr.tar% 压缩 tar 备份文件 usr.tar，此时压缩文件的扩展名为.tar.gz。","categories":[],"tags":[]},{"title":"搭建cocoapods私有库","slug":"搭建cocoapods私有库","date":"2018-10-29T07:55:02.000Z","updated":"2019-03-25T06:51:37.084Z","comments":true,"path":"2018/10/29/搭建cocoapods私有库/","link":"","permalink":"http://yoursite.com/2018/10/29/搭建cocoapods私有库/","excerpt":"Cocoapods 是一款swift和Objective-C项目的依赖管理工具，使用Cocoapods我们可以很方便的管理项目中的依赖库，本文将会介绍Cocoapods私有库的创建和使用。","text":"Cocoapods 是一款swift和Objective-C项目的依赖管理工具，使用Cocoapods我们可以很方便的管理项目中的依赖库，本文将会介绍Cocoapods私有库的创建和使用。 1.创建创建版本库使用GitHub或者码云创建一个新的远程Git仓库，创建好仓库后使用终端命令将该仓库添加到本地的版本仓库配置中，配置方式如下: 1pod repo add RepoName url 其中RepoName为私有库的名字(自行命名)，url 为创建的仓库的地址。创建好之后在Finder下查看目录~/.cocoapods/repo 可以查看到私有库名称对应的文件夹，并且在终端使用如下命令可以查看到Cocoapods的仓库配置列表中已经存在我们自己创建的私有库配置： 1pod repo list 如需移除多余的库可以使用如下命令 1pod repo remove RepoName 创建代码库同样新建一个远程的Git仓库，同时添加好License文件和README文件，将自己的代码添加并推送到该远程仓库，使用如下命令创建pod描述文件： 1pod spec create &lt;LibName&gt; 命令中的LibName替换成自己私有组件或模块的名称，podspec文件参考如下模板进行配置: 12345678910111213Pod::Spec.new do |s| s.name = &apos;LibName&apos; s.version = &apos;0.0.1&apos; s.summary = &apos;Lib描述&apos; s.license = &#123;:type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot;&#125; s.homepage = &quot;代码仓库主页的地址&quot; s.authors = &#123; &apos;test&apos; =&gt; &apos;test@qq.com&apos; &#125; #作者信息 s.source = &#123; :git =&gt; &quot;https://test.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; #仓库地址 s.source_files = &apos;Lib/*.&#123;h,m&#125;&apos; #代码位置 s.ios.deployment_target = &apos;8.0&apos; #支持的iOS版本 s.frameworks = &quot;UIKit&quot; #需要使用的框架 s.dependency &quot;Masonry&quot; #依赖的第三方 end 然后使用如下命令验证podspec文件配置是否正确。 1234# 本地验证pod lib lint LibName.podspec# 远程验证pod spec lint LibName.podspec 如有错误，根据提示修改，或者参数 --allow-warnings 或 --use-libraries 进行尝试。 验证通过后可以使用如下命令推送到私有库中 1pod repo push RepoName LibName.podspec 2.使用在Podfile文件中添加上如下配置 1234567# Cocoapods官方库地址source &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;私有库地址&apos; target &apos;targetName&apos; do pod &apos;私有库名称&apos;end 然后使用 install 命令 或者 update 命令进行操作就可以使用了。","categories":[],"tags":[]},{"title":"使用Hexo搭建自己的博客","slug":"使用Hexo搭建自己的博客","date":"2018-09-26T12:23:39.000Z","updated":"2018-10-29T06:44:56.000Z","comments":true,"path":"2018/09/26/使用Hexo搭建自己的博客/","link":"","permalink":"http://yoursite.com/2018/09/26/使用Hexo搭建自己的博客/","excerpt":"Hexo 是基于Node.js的一款快速、间接且高效的博客框架，支持Markdown，可更换主题，拥有丰富的插件，使用非常方便。","text":"Hexo 是基于Node.js的一款快速、间接且高效的博客框架，支持Markdown，可更换主题，拥有丰富的插件，使用非常方便。 Hexo官网 准备 Node.js Hexo Git GitHub账号 安装Node.js 点击 链接 到Node.js官网下载对应平台的安装程序即可安装。 安装Hexo 所有必备的应用程序安装完成后，即可使用npm安装Hexo。 1npm install -g hexo-cli 安装Git Windows下载并安装 Git Mac使用Homebrew：brew install git ；或下载 安装程序 安装。 配置GitHub仓库 注册一个 GitHub 账号 创建一个GitHub仓库新仓库名使用 “UserName”+“github.io” 的格式命名，之后访问的域名就会是 https://UserName.github.io 的形式 开启GitHub Page服务在仓库的 Settings 中找到 GitHub Pages 配置，并点击 Choose a theme 任意选择一个主题，此时会跳转到仓库，然后我们再查看 Settings 就可以看见开启 GitHub Pages 之后得到的域名，就可以使用该域名进行访问了 开始使用Hexo1.建立本地站点 首先在你想要用于存放站点的目录位置使用如下命令： 1hexo init &lt;folder&gt; 新建完成后，指定文件夹的目录如下 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 文件为站点的配置信息文件，可以用于修改一些网站参数，详细的配置参数可以参考Hexo官网的 文档。 package.json文件为站点的依赖配置文件，EJS，Stylus 和 Markdown render 已默认安装。 scaffolds为模板文件夹，当您新建文章时，Hexo会根据scaffold来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source为用户资源存放文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes为主题文件夹，用于存放Hexo的主题文件，Hexo 会根据主题来生成静态页面。 2.启用本地站点使用如下命令生成静态文件 1hexo generate 该命令可以使用如下参数 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 使用如下命令启动服务器。默认情况下，访问网址为：http://localhost:4000 。 1hexo server 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 3.关联GitHub编辑本地hexo目录下的_config.yml文件下的deploy配置，设置部署位置，如下： 12345deploy: type: git repository: &lt;repository url&gt; branch: [branch] message: [message] 参数 描述 repo 库（Repository）地址 branch 分支名称。如果您使用的是 GitHub 或者 GitCafe 的话，程序会尝试自动检测。 message 自定义提交信息（默认为 Site updated: YYYY-MM-DD HH:mm:ss） 然后可使用如下命令开始部署 1hexo deploy 参数 描述 -g, --generate 部署之前预先生成静态文件 部署完成后就可以使用 https://UserName.github.io 进行访问查看效果了。 4.新建一篇博客 使用如下命令新建一篇博客： 1hexo new post &quot;博客文章名&quot; 在生成及部署文章之前需要安装一个扩展，使用如下命令进行安装： 1npm install hexo-deployer-git --save 使用编辑器编辑好文章后使用命令：hexo d -g 生成并部署，完成之后使用 https://UserName.github.io 访问就可以查看到新生成的文章了。 5.更换主题首先在Hexo的官方 主题市场 中找到自己喜欢的主题，点击选中的主题进入到主题的GitHub仓库，复制主题仓库的地址，找到Hexo在本地的主目录(步骤1中存放的位置)，使用如下命令克隆主题文件： 1git clone &lt;repository url&gt; themes/&lt;主题名&gt; 或者进入Hexo主目录下的themes目录，将主题文件克隆至该目录下。注意： 部分主题可能需要安装插件，可以参考相应主题的说明文档进行设置。下载好主题的文件后需要修改Hexo的配置文件_config.yml (该文件存放于Hexo的主目录下)。修改其中的theme字段信息，参考如下： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 然后使用如下命令清楚缓存、重新生成、启动网站就可以看到效果了 123hexo cleanhexo ghexo s","categories":[],"tags":[]},{"title":"使用Jenkins+fastlane进行持续集成","slug":"使用Jenkins-fastlane进行持续集成","date":"2018-07-12T10:20:05.000Z","updated":"2018-10-29T06:44:56.000Z","comments":true,"path":"2018/07/12/使用Jenkins-fastlane进行持续集成/","link":"","permalink":"http://yoursite.com/2018/07/12/使用Jenkins-fastlane进行持续集成/","excerpt":"Jenkens是由Java语言开发的一个持续集成工具，使用Jenkins+fastlane可以帮助我们快速搭建一个iOS持续集成的环境。","text":"Jenkens是由Java语言开发的一个持续集成工具，使用Jenkins+fastlane可以帮助我们快速搭建一个iOS持续集成的环境。 1.新建任务在Jenkins中使用新建任务功能，设定好任务名称，并使用构建一个自由风格的软件项目方式创建一个任务 2.配置任务信息设置任务的描述；设置丢弃旧的构建，使用默认的策略方式即可，“保存构建的天数“ 和 ”保持构建的最大个数“可根据个人需求进行配置。 配置任务的Git地址、访问Git的凭证(账号密码或者使用SSH)、使用的分支 3.设置构建触发器定时构建： 一般设置为H 20 (注意使用空格分隔) 每天20点定时执行轮询 SCM：需要设置源码路径才能起到轮询的效果，一般设置为 H/5 * (注意使用空格分隔) 每5分钟轮询一次 4设置构建方式在构建设置中使用增加构建步骤添加执行shell方式来进行构建，此处为了简化构建命令设置，已事先在项目中集成fastlane，fastlane的集成方式可以参考链接使用的shell脚本如下 1234567#!/bin/bash#切换到项目目录cd DDKanQiu#执行pod更新依赖pod update --no-repo-update#使用fastlane打包命令fastlane beta 注意：使用shell脚本时，请提前配置好Jenkins的环境变量，可以使用如下命令获取当前系统的环境变量1echo $PATH 通过Jenkins的 系统管理 - 系统设置 - 全局属性 - 环境变量 进行设置，点击增加，增加环境变量配置 至此，任务的配置已经完成了，可以保存设置并立即开始构建了。可以通过构建记录查询构建的状态，如果构建失败，可以通过控制台输出查看log输出查找失败原因，有时可能因为一些环境配置的不正确导致构建失败，耐心检查控制台输出可能有助于你快速找到问题原因。另外，由于之前直接使用Mac平台的pkg安装包安装Jenkins，Jenkins会在系统的用户目录的共享目录下创建Jenkins的工作目录，Jenkins拉取的项目代码也会存于此路径下，这种情况可能由于MacOS的权限限制导致部分项目管理工具无法正常运行(例如我在使用过程中发现cocoapods无法正常工作)，网上说是需要将Jenkins的用户设置为root用户(我没有测试过)。为此，我改用了Tomcat+Jenkins的war包的方式重新部署了Jenkins并解决了问题。","categories":[],"tags":[]},{"title":"fastlane集成与使用","slug":"fastlane集成与使用","date":"2018-05-19T10:21:10.000Z","updated":"2018-10-29T06:44:56.000Z","comments":true,"path":"2018/05/19/fastlane集成与使用/","link":"","permalink":"http://yoursite.com/2018/05/19/fastlane集成与使用/","excerpt":"fastlane 是一款使用ruby开发的自动化工具集，使用它可以简化我们部署项目的过程，实现自动化部署，提高工作效率。","text":"fastlane 是一款使用ruby开发的自动化工具集，使用它可以简化我们部署项目的过程，实现自动化部署，提高工作效率。 GitHub 1.环境安装1.确定ruby是否安装，使用ruby -v 查看ruby版本1ruby -v 2.安装Xcode命令行工具，使用如下命令进行安装1xcode-select --install 如果出现1xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 代表已安装，否则根据提示进行操作即可安装 3.安装fastlane，使用如下命令进行安装，安装需要一点等待时间1sudo gem install fastlane 2.使用fastlane打包并上传到蒲公英1.安装蒲公英插件，在终端中输入如下命令进行安装1fastlane add_plugin pgyer 出现如下信息说明安装成功 2.初始化切换到Xcode工程目录下面，使用如下命令进行初始化1fastlane init 初始化过程中会出现以下选项，目前使用的是第4个选项12345[15:52:35]: What would you like to use fastlane for?1. 📸 Automate screenshots2. 👩‍✈️ Automate beta distribution to TestFlight3. 🚀 Automate App Store distribution4. 🛠 Manual setup - manually setup your project to automate your tasks 12341.自动截屏(暂未使用)2.自动发布测试版本到 TestFlight3.自动发布到App Store4.手动配置 初始过程中会出现一些提示，根据提示信息一直按Enter键就好了，初始完成后的打印信息如下 1234567891011121314[16:03:36]: ------------------------------[16:03:36]: --- Where to go from here? ---[16:03:36]: ------------------------------[16:03:36]: 📸 Learn more about how to automatically generate localized App Store screenshots:[16:03:36]: https://docs.fastlane.tools/getting-started/ios/screenshots/[16:03:36]: 👩‍✈️ Learn more about distribution to beta testing services:[16:03:36]: https://docs.fastlane.tools/getting-started/ios/beta-deployment/[16:03:36]: 🚀 Learn more about how to automate the App Store release process:[16:03:36]: https://docs.fastlane.tools/getting-started/ios/appstore-deployment/[16:03:36]: 👩‍⚕️ Learn more about how to setup code signing with fastlane[16:03:36]: https://docs.fastlane.tools/codesigning/getting-started/[16:03:36]: [16:03:36]: To try your new fastlane setup, just enter and run[16:03:36]: $ fastlane custom_lane 初始化完成后会在项目目录下生成一些文件，如下图 3.设置配置文件 Fastfile然后，找到在用的工作流（action），在 build_app 指令后，加入蒲公英插件的配置信息1234lane :beta do build_app(export_method: &quot;ad-hoc&quot;) pgyer(api_key: &quot;7f15xxxxxxxxxxxxxxxxxx141&quot;, user_key: &quot;4a5bcxxxxxxxxxxxxxxx3a9e&quot;)end 注意： 以上的 api_key 和 user_key，在自己账号下的 应用管理 - App概述 - API 中可以找到，并替换到以上相应的位置。 在 Xcode 8.3 和 Xcode 8.3 以后的版本中，对于 build_app 的 export_method 的值，需要根据开发者的打包类型进行设置，可选的值有：app-store、ad-hoc、development、enterprise。对于 Xcode 8.3 以下的版本，则不需要设置 export_method。 4.完成以上配置后在终端中输入以下命令就可以使用了1fastlane beta","categories":[],"tags":[]}]}